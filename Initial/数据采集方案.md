# 一. ADS1115 + Arduino的数据采集流程
[cite\_start]ADS1115是一款非常流行且易于使用的高精度模数转换器（ADC）。对于你们的项目来说，它是一个绝佳的选择，因为它能帮你实现“自动化多通道数据采集” [cite: 273]，并且其特性非常适合测量热电芯片产生的微弱电压信号。



### 1\. 什么是ADS1115？

  * **高精度ADC**：它是一个**16位**的模数转换器。相比之下，标准Arduino Uno上的ADC只有10位。这意味着ADS1115的测量精度要高得多（$2^{16}=65536$个级别，而10位只有$2^{10}=1024$个级别）。
  * **I2C接口**：它使用I2C通信协议。这意味着你只需要两根线（SCL和SDA）就可以和微控制器（如Arduino或ESP32）通信，非常节省引脚。
  * **多通道**：它有4个模拟输入通道（A0, A1, A2, A3）。你可以将它们用作4个独立的“单端”输入，或者两对“差分”输入。
  * [cite\_start]**内置放大器 (PGA)**：这是它最关键的特性之一。它有一个**可编程增益放大器（PGA）** [cite: 273]，可以合法地“放大”你输入的微弱信号。这对于热电芯片的毫伏（mV）级别信号来说是完美的。

### 2\. 硬件连接（以Arduino为例）

你只需要连接4根线即可让模块工作：

| ADS1115 引脚 | 连接到 Arduino | 说明 |
| :--- | :--- | :--- |
| **VDD** | `5V` 或 `3.3V` | 电源。请检查你的模块版本所支持的电压。 |
| **GND** | `GND` | 地线。 |
| **SCL** | `SCL` (或 `A5`) | I2C 时钟线。 |
| **SDA** | `SDA` (或 `A4`) | I2C 数据线。 |

**重要：连接热电芯片**

[cite\_start]对于你们的项目，**强烈推荐使用差分模式**，这能极大地抑制噪声，测量结果更稳定 [cite: 247, 276]：

  * 将热电芯片的**P脚**连接到 `A0`
  * 将热电芯片的**N脚**连接到 `A1`

这样，ADS1115将直接测量A0和A1之间的**电压差**，这正是热电芯片产生的信号。

### 3\. 如何设置I2C地址（多模块）

ADS1115还有一个`ADDR`引脚，用于设置I2C地址。这让你可以**在同一个I2C总线上挂载多个ADS1115模块**。例如，在你们的“双灶-双谱”方案中，一个ADS1115就可以同时采集两个灶上的芯片信号：

  * `ADDR` 接 `GND` (默认地址, 0x48)
  * `ADDR` 接 `VDD` (地址 0x49)
  * `ADDR` 接 `SDA` (地址 0x4A)
  * `ADDR` 接 `SCL` (地址 0x4B)

### 4\. 软件使用（推荐使用库）

最简单的方法是使用**Adafruit的ADS1X15库**。

**步骤 1：安装库**
在Arduino IDE中，进入 “工具” -\> “管理库”，搜索 `Adafruit ADS1X15` 并安装。

**步骤 2：编写代码（差分读取示例）**

```cpp
#include <Wire.h>
#include <Adafruit_ADS1015.h> // 库名是1015，但它同时支持ADS1115

// 创建一个ADS1115实例
Adafruit_ADS1115 ads;  

void setup() {
  Serial.begin(9600);
  Serial.println("Getting differential reading from A0-A1");
  
  // 初始化ADS1115
  // ads.setAddr_ADS1115(0x48); // 如果你用了非默认地址，用这行来指定
  ads.begin();
  
  // *** 这是最关键的一步：设置增益 ***
  // 因为热电芯片电压很低 (mV级别)，你需要开启放大器
  // GAIN_SIXTEEN   = ±0.256V (1 bit = 0.0078125mV) <--- 推荐用于TEC芯片
  // GAIN_EIGHT     = ±0.512V
  // GAIN_FOUR      = ±1.024V
  // GAIN_TWO       = ±2.048V
  // GAIN_ONE       = ±4.096V
  // GAIN_TWOTHIRDS = ±6.144V (默认值)
  ads.setGain(GAIN_SIXTEEN); 
}

void loop() {
  int16_t adc01; // 16位有符号整数
  float voltage_mV;

  // 读取 A0 和 A1 之间的差分电压
  adc01 = ads.readADC_Differential_0_1();  

  // 将读取到的原始值 (adc01) 转换为毫伏 (mV)
  // 转换系数取决于你设置的增益。
  // 对于 GAIN_SIXTEEN (±0.256V)，转换系数是 0.0078125mV
  voltage_mV = adc01 * 0.0078125;

  Serial.print("ADC 0/1 Differential: ");
  Serial.print(adc01);
  Serial.print(" (");
  Serial.print(voltage_mV);
  Serial.println(" mV)");

  delay(1000); // 每秒读取一次
}
```

通过这个设置，你就可以构建一个高精度、抗干扰的自动化数据采集系统，为后续的CNN训练提供海量的高质量数据。

# 二. 基于ADS1115的不同数据采集流程

### 方案一：Raspberry Pi (树莓派) - 最强大的选择

这是最推荐的方案，它完美符合你的“纯Python”要求。

  * **是什么**：一个完整的、带GPIO引脚的微型电脑。它运行Linux系统，你可以像操作普通电脑一样操作它，并且它原生支持Python。
  * **如何使用**：
    1.  **硬件**：将ADS1115的VDD, GND, SCL, SDA**直接连接**到树莓派的5V/3.3V, GND, SCL, SDA引脚上。（树莓派天生就有I2C引脚！）
    2.  **软件**：在树莓派的Linux系统里，打开一个终端。
    3.  安装Python库：`pip install adafruit-circuitpython-ads1x15`
    4.  **在PyCharm中编写代码**：你可以在你的笔记本上安装PyCharm，使用它的\*\*“远程SSH解释器”\*\*功能，直接连接到树莓派。这样你就是在你的Jetbrains IDE里写代码，而代码却是在树莓派上“纯Python”运行的。
  * **示例代码 (Python on Raspberry Pi)**：
    ```python
    import board
    import busio
    import adafruit_ads1x15.ads1115 as ADS
    from adafruit_ads1x15.analog_in import AnalogIn

    # 创建I2C总线
    i2c = busio.I2C(board.SCL, board.SDA)

    # 创建ADS1115对象
    ads = ADS.ADS1115(i2c)

    # 设置增益 (GAIN_SIXTEEN = ±0.256V)
    ads.gain = 16 

    # 创建一个差分输入通道 (A0 和 A1)
    chan = AnalogIn(ads, ADS.P0, ADS.P1)

    # 循环读取
    while True:
        print(f"差分电压: {chan.voltage:.6f} V, 原始值: {chan.value}")
        time.sleep(1)
    ```
  * **优点**：一步到位。你不仅可以用Python采集，还能直接在上面跑你的CNN模型。
  * **缺点**：比Arduino贵，需要一点点Linux基础。

-----

### 方案二：MicroPython / CircuitPython (如 RPi Pico, ESP32) - 最简单的“Python方案”

这可能是你想要的\*\*“更简单”\*\*的方案。它用Python取代了Arduino的C++语言。

  * **是什么**：一种微控制器（像Arduino），但它不运行C++，而是**直接运行Python**（一种叫MicroPython或CircuitPython的精简版Python）。
  * **如何使用**：
    1.  **硬件**：像Arduino一样，把ADS1115连接到Pico或ESP32的I2C引脚。
    2.  **软件**：使用一个叫**Thonny**的简单IDE（Jetbrains的IDE也可以通过插件支持）。你写的Python代码会**保存到这个小板子上**，然后它就像Arduino一样独立运行。
  * **优点**：和Arduino一样便宜简单，但你写的是Python。
  * **缺点**：不是“全功能”的Python，你不能在上面直接跑复杂的CNN（但可以采集数据传给电脑练）。

-----

### 方案三：USB-to-I2C 适配器 (如 FT232H) - 最“纯粹”的方案

这个方案让你**在你的电脑上**用PyCharm“纯Python”**直接**控制I2C引脚。

  * **是什么**：一个USB小板，它插在你的电脑USB口上，另一端提供了I2C (SCL/SDA)引脚。它充当了一个“翻译官”。
  * **如何使用**：
    1.  **硬件**：ADS1115连接到FT232H的I2C引脚，FT232H插入电脑USB。
    2.  **软件**：在你的电脑上（Windows/Mac）安装Python的`adafruit-blinka`库。这个库会“欺骗”你的Python脚本，让它以为你的电脑有GPIO引脚。
    3.  **IDE**：直接在你的Jetbrains IDE里打开Python脚本并运行。
  * **优点**：真正实现了在你的主力电脑上用PyCharm直接运行Python来控制硬件。
  * **缺点**：驱动安装可能比Arduino麻烦，这个硬件本身不如树莓派或Pico常见。

### 总结和建议

| 方案 | 硬件 | 运行Python的位置 | Jetbrains IDE | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Arduino (基线)** | Arduino Uno | 电脑 (C++在板子上) | 可以 (但麻烦) | 课程标配 | 需要学C++, 手动串口通信 |
| **1. 树莓派** | Raspberry Pi | **树莓派上** | **完美 (远程SSH)** | **一步到位, Python采集+训练** | 稍贵, 需配置Linux |
| **2. MicroPython** | RPi Pico / ESP32 | **Pico/ESP32上** | 可以 (需插件) | **便宜, 简单, 纯Python** | Python功能受限 |
| **3. USB-I2C桥** | FT232H | **你的电脑上** | **完美 (本地运行)** | 最“纯粹”的PC直控 | 驱动配置稍烦 |


# 三、ADS1115 + Raspberry Pi数据采集流程
这绝对是树莓派（Raspberry Pi）最擅长的应用场景，它能完美地充当你的“自动化数据采集下位机”，而你则可以在PC上舒适地使用Jetbrains IDE（如PyCharm）进行“纯Python”开发。

这个工作流分为两大部分：

1.  **硬件连接**：将ADS1115和热电芯片物理连接到树莓派。
2.  **远程开发**：在你的PC上设置PyCharm，通过网络SSH连接到树莓派，实现代码编写、运行和数据回传。

-----

### 第1部分：数据采集阶段的硬件连接

你需要将ADS1115作为“桥梁”，连接树莓派（主控）和热电芯片（传感器）。

**必备材料：**

  * 树莓派（Pi 4, Pi 5, 或 Pi 3B+ 均可）
  * ADS1115模块
  * 你的热电芯片（TEC）
  * 杜邦线（公对母，母对母）

#### 步骤1：连接树莓派与ADS1115（I2C通信）

树莓派通过I2C总线（两根线）来控制ADS1115。你需要连接4根线：

| 树莓派 (40-pin Header) | ADS1115 模块 | 说明 |
| :--- | :--- | :--- |
| **Pin 1 (3.3V Power)** | `VDD` | 供电。使用3.3V更安全。 |
| **Pin 6 (GND)** | `GND` | 地线，使两者共地。 |
| **Pin 3 (GPIO 2 / SDA)** | `SDA` | I2C 数据线。 |
| **Pin 5 (GPIO 3 / SCL)** | `SCL` | I2C 时钟线。 |

*(提示：树莓派的引脚图可以在线搜到，`Pin 1`是靠近SD卡槽那一侧的角落。)*

#### 步骤2：连接ADS1115与热电芯片（差分测量）

这是你们项目的核心。为了最精确地测量热电芯片的微弱电压差并抑制噪声，你必须使用**差分模式**。

  * 将**热电芯片的P脚**（正极） -\> 连接到 `A0`
  * 将**热电芯片的N脚**（负极） -\> 连接到 `A1`

**这就完成了！** ADS1115现在会去测量`A0`和`A1`之间的电压**差值**。

如果你要实现“双灶”方案，只需：

  * 将**第二个热电芯片的P脚** -\> 连接到 `A2`
  * 将**第二个热电芯片的N脚** -\> 连接到 `A3`

这样，一个ADS1115就能**同时**采集两路差分信号。

-----

### 第2部分：PC连接树莓派 (远程开发工作流)

这是最酷的部分。你不需要给树莓派接显示器或键盘。它只需要接上电源和连上网络（WiFi或网线）就行。

#### 步骤1：树莓派的“无头”启动（一次性配置）

1.  **安装系统**：使用 "Raspberry Pi Imager" 工具，在SD卡上烧录 "Raspberry Pi OS (64-bit)"。
2.  **开启SSH和网络**：在烧录设置中（点击小齿轮图标），**必须**：
      * 勾选 "Enable SSH"。
      * 设置一个你自己的用户名和密码（例如 `pi` / `raspberry`）。
      * 配置好你的WiFi名称（SSID）和密码。
3.  **启动**：将SD卡插入树莓派，通电。它会自动连接到你的WiFi。
4.  **找到IP地址**：登录你的路由器管理界面，在“已连接设备”里找到你的树莓派，记下它的IP地址（例如 `192.168.1.10`）。
5.  **开启I2C**：
      * 在你的PC上打开终端（Windows可用PowerShell）。
      * 输入 `ssh pi@192.168.1.10` （替换成你的用户名和IP）。
      * 输入密码，登录到树莓派的命令行。
      * 运行 `sudo raspi-config`。
      * 选择 `3 - Interface Options` -\> `I5 - I2C` -\> "Yes" 开启I2C。
      * 重启 (`sudo reboot`)。

#### 步骤2：在PyCharm中配置“远程SSH解释器”

这是实现Jetbrains IDE开发的核心。

1.  **打开PyCharm** (专业版支持此功能)。
2.  **创建新项目**：在你的PC上创建一个空项目（例如 `Sky_Radiation_Project`）。
3.  **添加远程解释器**：
      * 进入 `Settings/Preferences` \> `Project: [Your_Project_Name]` \> `Python Interpreter`。
      * 点击小齿轮，选择 `Add...`。
      * 在左侧选择 `SSH`。
      * **Host**：填入树莓派的IP (如 `192.168.1.10`)
      * **Username**：填入你的用户名 (如 `pi`)
      * 点击 `Next`，输入你的密码。
      * PyCharm会连接到树莓派。在下一个界面，它会问你“解释器路径”。通常你直接选择系统自带的Python 3路径（如 `/usr/bin/python3`）即可。
      * **重要**：设置“Sync folders”（同步路径）。将你的PC项目路径 (e.g., `C:\Users\...\Sky_Radiation_Project`) 映射到树莓派上的一个路径 (e.g., `/home/pi/Sky_Radiation_Project`)。
4.  **完成**：点击 `OK` 保存。PyCharm会自动配置一切。

#### 步骤3：开始编写和运行代码

1.  **安装库**：现在PyCharm的终端已经连接到树莓派。在PyCharm底部的 "Terminal" 标签页中，输入以下命令（这会在**树莓派**上安装库）：
    ```bash
    pip install adafruit-circuitpython-ads1x15
    pip install adafruit-blinka 
    ```
2.  **编写代码**：在PyCharm的项目中新建一个Python文件（例如 `collector.py`）。这个文件会自动同步到树莓派上。
3.  **运行**：点击PyCharm的绿色“▶︎”运行按钮。
4.  **工作原理**：PyCharm会通过SSH将你的 `collector.py` 脚本发送到树莓派，在树莓派上执行它，然后把所有的 `print()` 输出实时传回，显示在你PC上PyCharm的“Run”窗口里！

#### 步骤4：数据处理和回传

你的`collector.py`脚本应该如何设计？

  * **实时监测 (方法A)**：直接使用 `print()`。

    ```python
    # collector.py (在树莓派上运行)
    import time
    # (此处省略I2C和ADS1115的设置代码)

    while True:
        v1 = get_differential_voltage(ads, 'A0', 'A1') # 你自己封装的函数
        v2 = get_differential_voltage(ads, 'A2', 'A3')
        
        # 这个print会显示在你PC的PyCharm里
        print(f"Time: {time.time()}, V_SW: {v1:.6f}, V_LW: {v2:.6f}") 
        time.sleep(1)
    ```

  * **保存数据集 (方法B - 推荐)**：将数据写入文件，然后用PyCharm下载。

    ```python
    # collector.py (在树莓派上运行)
    import csv, time
    # (设置代码)

    # 在树莓派上创建一个CSV文件
    with open('radiation_data.csv', 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['timestamp', 'V_SW', 'V_LW']) # 写入表头
        
        try:
            while True:
                v1 = ...
                v2 = ...
                timestamp = time.time()
                
                # 写入一行数据
                writer.writerow([timestamp, v1, v2]) 
                f.flush() # 立即写入磁盘
                
                print(f"Wrote data at {timestamp}") # 仍在PC上显示日志
                time.sleep(0.5) # 实现高频采集
        except KeyboardInterrupt:
            print("停止采集")
    ```

    当你停止脚本后，在PyCharm左侧的项目浏览器中，右键点击“远程主机”（Remote Host）标签页，你就能看到树莓派上的文件系统，找到 `radiation_data.csv`，右键点击 `Download` 即可将其下载到你的PC，用于后续的CNN训练。